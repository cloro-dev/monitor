generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  user      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model session {
  id                   String   @id
  expiresAt            DateTime
  token                String   @unique
  createdAt            DateTime
  updatedAt            DateTime
  ipAddress            String?
  userAgent            String?
  userId               String
  activeOrganizationId String?
  user                 user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model user {
  id            String       @id
  name          String
  email         String       @unique
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  account       account[]
  session       session[]
  prompts       prompt[]
  members       member[]
  invitations   invitation[]
}

enum PromptStatus {
  ACTIVE
  SUGGESTED
  ARCHIVED
}

model prompt {
  id        String       @id @default(cuid())
  text      String
  country   String
  status    PromptStatus @default(ACTIVE)
  userId    String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  user      user         @relation(fields: [userId], references: [id], onDelete: Cascade)
  brand     brand        @relation(fields: [brandId], references: [id], onDelete: Cascade)
  brandId   String
  results   Result[]

  @@index([userId])
  @@index([country])
  @@index([brandId])
  @@index([status, createdAt(sort: Desc)])
}

model verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
}

model organization {
  id                 String               @id @default(cuid())
  name               String
  slug               String               @unique
  logo               String?
  metadata           Json?
  aiModels           Json? // Store enabled AI models as JSON array
  createdAt          DateTime             @default(now())
  members            member[]
  invitations        invitation[]
  organizationBrands organization_brand[]
  brandMetrics       BrandMetrics[]
  sourceMetrics      SourceMetrics[]
}

model brand {
  id                 String               @id @default(cuid())
  domain             String               @unique
  name               String?
  description        String?
  defaultCountry     String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  organizationBrands organization_brand[]
  prompts            prompt[]
  competitors        Competitor[]         @relation("BrandToCompetitor")
  competitorOf       Competitor[]         @relation("CompetitorToBrand")
  brandMetrics       BrandMetrics[]       @relation("BrandMetricsBrand")
  competitorMetrics  BrandMetrics[]       @relation("BrandMetricsCompetitor")
  sourceMetrics      SourceMetrics[]      @relation("SourceMetricsBrand")

  @@index([domain])
  @@index([name])
}

model organization_brand {
  id             String   @id @default(cuid())
  organizationId String
  brandId        String
  role           String   @default("member") // member, admin, viewer
  createdAt      DateTime @default(now())

  organization organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  brand        brand        @relation(fields: [brandId], references: [id], onDelete: Cascade)

  @@unique([organizationId, brandId])
  @@index([organizationId])
  @@index([brandId])
  @@map("organization_brand")
}

model member {
  id             String       @id @default(cuid())
  userId         String
  organizationId String
  role           String
  createdAt      DateTime     @default(now())
  user           user         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization   organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
}

model invitation {
  id             String       @id @default(cuid())
  email          String
  inviterId      String
  organizationId String
  role           String
  status         String
  expiresAt      DateTime
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  inviter        user         @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  organization   organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
}

enum TrackingStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
}

enum ProviderModel {
  CHATGPT
  PERPLEXITY
  COPILOT
  GEMINI
  AIMODE
  AIOVERVIEW
  GROK
}

model Result {
  id          String         @id @default(cuid())
  prompt      prompt         @relation(fields: [promptId], references: [id], onDelete: Cascade)
  promptId    String
  model       ProviderModel
  status      TrackingStatus @default(PENDING)
  response    Json?
  sentiment   Float?
  position    Int?
  competitors Json?
  sources     Source[]       @relation("ResultSources")
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([promptId])
  @@index([model])
  @@index([status, createdAt(sort: Desc)])
  @@index([createdAt], name: "result_createdAt_idx")
  @@map("result")
}

model Source {
  id        String          @id @default(cuid())
  url       String          @unique
  hostname  String
  title     String?
  type      String?
  results   Result[]        @relation("ResultSources")
  metrics   SourceMetrics[]
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([hostname])
  @@map("source")
}

enum CompetitorStatus {
  ACCEPTED
  REJECTED
}

model Competitor {
  id           String            @id @default(cuid())
  brandId      String
  brand        brand             @relation("BrandToCompetitor", fields: [brandId], references: [id], onDelete: Cascade)
  competitorId String
  competitor   brand             @relation("CompetitorToBrand", fields: [competitorId], references: [id], onDelete: Cascade)
  status       CompetitorStatus?
  mentions     Int               @default(1)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@unique([brandId, competitorId])
  @@index([brandId])
  @@index([competitorId])
  @@map("competitor")
}

model SourceMetrics {
  id             String        @id @default(cuid())
  brandId        String
  organizationId String
  sourceId       String
  date           DateTime      @db.Date
  model          ProviderModel

  // Pre-calculated source metrics for the day
  totalMentions  Int           @default(0)
  uniquePrompts  Int           @default(0)
  utilization    Float         @default(0)  // (uniquePrompts / totalPrompts) * 100

  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  source         Source        @relation(fields: [sourceId], references: [id])
  brand          brand         @relation("SourceMetricsBrand", fields: [brandId], references: [id], onDelete: Cascade)
  organization   organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([brandId, organizationId, sourceId, date, model])
  @@index([brandId, date(sort: Desc)])
  @@index([organizationId, date(sort: Desc)])
  @@index([sourceId, date(sort: Desc)])
  @@index([brandId, organizationId, date])
  @@index([date], name: "source_metrics_date_idx")
  @@map("source_metrics")
}

model BrandMetrics {
  id             String        @id @default(cuid())
  brandId        String
  organizationId String
  competitorId   String? // null for own brand metrics
  date           DateTime      @db.Date
  model          ProviderModel

  // Pre-calculated metrics
  totalMentions    Int    @default(0)
  averagePosition  Float?
  averageSentiment Float?
  visibilityScore  Float  @default(0)
  totalResults     Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brand        brand        @relation("BrandMetricsBrand", fields: [brandId], references: [id], onDelete: Cascade)
  organization organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  competitor   brand?       @relation("BrandMetricsCompetitor", fields: [competitorId], references: [id], onDelete: Cascade)

  @@unique([brandId, organizationId, competitorId, date, model])
  @@index([brandId, date(sort: Desc)])
  @@index([organizationId, date(sort: Desc)])
  @@index([competitorId, date(sort: Desc)])
  @@index([date], name: "brand_metrics_date_idx")
  @@map("brand_metrics")
}

model PrecomputedSourceChart {
  id              String   @id @default(cuid())
  brandId         String
  organizationId  String
  timeRange       String // '7d', '30d', '90d'
  tab             String // 'domain', 'url'
  chartData       Json // Serialized chart data
  chartConfig     Json // Top 5 sources + config
  date            DateTime // Last computation date
  updatedAt       DateTime @updatedAt

  @@unique([brandId, organizationId, timeRange, tab])
  @@index([brandId])
  @@index([organizationId])
  @@index([date(sort: Desc)])
  @@map("precomputed_source_chart")
}

model PrecomputedCompetitorChart {
  id              String   @id @default(cuid())
  brandId         String
  organizationId  String
  lookbackDays    Int // 90
  chartData       Json
  chartConfig     Json
  date            DateTime
  updatedAt       DateTime @updatedAt

  @@unique([brandId, organizationId])
  @@index([brandId])
  @@index([organizationId])
  @@index([date(sort: Desc)])
  @@map("precomputed_competitor_chart")
}
